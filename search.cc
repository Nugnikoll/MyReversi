#include <algorithm>

#include "reversi.h"
#include "search.h"
#include "pattern.h"

calc_type table_val[board::size2][board::size2];
trans_type table_trans;

const calc_type table_val_init[board::size2] = {
	0.0010,0.0003,0.0007,0.0008,0.0008,0.0007,0.0003,0.0010,
	0.0003,0.0002,0.0004,0.0005,0.0005,0.0004,0.0002,0.0003,
	0.0007,0.0004,0.0009,0.0006,0.0006,0.0009,0.0004,0.0007,
	0.0008,0.0005,0.0006,0.0001,0.0001,0.0006,0.0005,0.0008,
	0.0008,0.0005,0.0006,0.0001,0.0001,0.0006,0.0005,0.0008,
	0.0007,0.0004,0.0009,0.0006,0.0006,0.0009,0.0004,0.0007,
	0.0003,0.0002,0.0004,0.0005,0.0005,0.0004,0.0002,0.0003,
	0.0010,0.0003,0.0007,0.0008,0.0008,0.0007,0.0003,0.0010
};

void board::config_search(){}

#ifdef __GNUC__
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wswitch"
#endif

calc_type board::search(
	cmethod mthd,cbool color,cshort height,
	ccalc_type alpha,ccalc_type beta,ccalc_type gamma
)const{

	if(height < 0){
		short total = this->sum();
		if(total <= 7){
			height = 9;
		}else if(total <= 10){
			height = 8;
		}else if(total <= size2 - 22){
			height = 7;
		}else if(total <= size2 - 15){
			height = 8;
		}else{
			height = 20;
		}
	}

	/*
		// This part of code is generated by:

		str = ["mthd_ab","mthd_kill","mthd_pvs","mthd_trans","mthd_ptn"];

		size = len(str);
		length = 1 << size;

		result = "";
		for i in range(length):
			s = [];
			for j in range(size):
				if i & (1 << j):
					s += [str[j]];
			s = (
				"case " + "|".join(s) + " :\n"
				+ "\treturn board::search<method(" + "|".join(s) + ")>(color,height,alpha,beta);\n"
			);
			result += s;

		print(result);
	*/

	switch(mthd){
	case mthd_rnd :
		return board::search<method(mthd_rnd)>(color,height,alpha,beta);
	case mthd_ab :
		return board::search<method(mthd_ab)>(color,height,alpha,beta);
	case mthd_kill :
		return board::search<method(mthd_kill)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill :
		return board::search<method(mthd_ab|mthd_kill)>(color,height,alpha,beta);
	case mthd_pvs :
		return board::search<method(mthd_pvs)>(color,height,alpha,beta);
	case mthd_ab|mthd_pvs :
		return board::search<method(mthd_ab|mthd_pvs)>(color,height,alpha,beta);
	case mthd_kill|mthd_pvs :
		return board::search<method(mthd_kill|mthd_pvs)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_pvs :
		return board::search<method(mthd_ab|mthd_kill|mthd_pvs)>(color,height,alpha,beta);
	case mthd_trans :
		return board::search<method(mthd_trans)>(color,height,alpha,beta);
	case mthd_ab|mthd_trans :
		return board::search<method(mthd_ab|mthd_trans)>(color,height,alpha,beta);
	case mthd_kill|mthd_trans :
		return board::search<method(mthd_kill|mthd_trans)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_trans :
		return board::search<method(mthd_ab|mthd_kill|mthd_trans)>(color,height,alpha,beta);
	case mthd_pvs|mthd_trans :
		return board::search<method(mthd_pvs|mthd_trans)>(color,height,alpha,beta);
	case mthd_ab|mthd_pvs|mthd_trans :
		return board::search<method(mthd_ab|mthd_pvs|mthd_trans)>(color,height,alpha,beta);
	case mthd_kill|mthd_pvs|mthd_trans :
		return board::search<method(mthd_kill|mthd_pvs|mthd_trans)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_pvs|mthd_trans :
		return board::search<method(mthd_ab|mthd_kill|mthd_pvs|mthd_trans)>(color,height,alpha,beta);
	case mthd_ptn :
		return board::search<method(mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_ptn :
		return board::search<method(mthd_ab|mthd_ptn)>(color,height,alpha,beta);
	case mthd_kill|mthd_ptn :
		return board::search<method(mthd_kill|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_ptn :
		return board::search<method(mthd_ab|mthd_kill|mthd_ptn)>(color,height,alpha,beta);
	case mthd_pvs|mthd_ptn :
		return board::search<method(mthd_pvs|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_pvs|mthd_ptn :
		return board::search<method(mthd_ab|mthd_pvs|mthd_ptn)>(color,height,alpha,beta);
	case mthd_kill|mthd_pvs|mthd_ptn :
		return board::search<method(mthd_kill|mthd_pvs|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_pvs|mthd_ptn :
		return board::search<method(mthd_ab|mthd_kill|mthd_pvs|mthd_ptn)>(color,height,alpha,beta);
	case mthd_trans|mthd_ptn :
		return board::search<method(mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_trans|mthd_ptn :
		return board::search<method(mthd_ab|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_kill|mthd_trans|mthd_ptn :
		return board::search<method(mthd_kill|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_trans|mthd_ptn :
		return board::search<method(mthd_ab|mthd_kill|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_pvs|mthd_trans|mthd_ptn :
		return board::search<method(mthd_pvs|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_pvs|mthd_trans|mthd_ptn :
		return board::search<method(mthd_ab|mthd_pvs|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_kill|mthd_pvs|mthd_trans|mthd_ptn :
		return board::search<method(mthd_kill|mthd_pvs|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	case mthd_ab|mthd_kill|mthd_pvs|mthd_trans|mthd_ptn :
		return board::search<method(mthd_ab|mthd_kill|mthd_pvs|mthd_trans|mthd_ptn)>(color,height,alpha,beta);
	default:
		assert(false);
		return 0;
	}

};

#ifdef __GNUC__
	#pragma GCC diagnostic pop
#endif

const brd_type mask_after[board::size2] = {
	0xfffffffffffffffe,
	0xfffffffffffffffc,
	0xfffffffffffffff8,
	0xfffffffffffffff0,
	0xffffffffffffffe0,
	0xffffffffffffffc0,
	0xffffffffffffff80,
	0xffffffffffffff00,
	0xfffffffffffffe00,
	0xfffffffffffffc00,
	0xfffffffffffff800,
	0xfffffffffffff000,
	0xffffffffffffe000,
	0xffffffffffffc000,
	0xffffffffffff8000,
	0xffffffffffff0000,
	0xfffffffffffe0000,
	0xfffffffffffc0000,
	0xfffffffffff80000,
	0xfffffffffff00000,
	0xffffffffffe00000,
	0xffffffffffc00000,
	0xffffffffff800000,
	0xffffffffff000000,
	0xfffffffffe000000,
	0xfffffffffc000000,
	0xfffffffff8000000,
	0xfffffffff0000000,
	0xffffffffe0000000,
	0xffffffffc0000000,
	0xffffffff80000000,
	0xffffffff00000000,
	0xfffffffe00000000,
	0xfffffffc00000000,
	0xfffffff800000000,
	0xfffffff000000000,
	0xffffffe000000000,
	0xffffffc000000000,
	0xffffff8000000000,
	0xffffff0000000000,
	0xfffffe0000000000,
	0xfffffc0000000000,
	0xfffff80000000000,
	0xfffff00000000000,
	0xffffe00000000000,
	0xffffc00000000000,
	0xffff800000000000,
	0xffff000000000000,
	0xfffe000000000000,
	0xfffc000000000000,
	0xfff8000000000000,
	0xfff0000000000000,
	0xffe0000000000000,
	0xffc0000000000000,
	0xff80000000000000,
	0xff00000000000000,
	0xfe00000000000000,
	0xfc00000000000000,
	0xf800000000000000,
	0xf000000000000000,
	0xe000000000000000,
	0xc000000000000000,
	0x8000000000000000,
	0x0000000000000000
};

template<method mthd>
calc_type board::search(cbool color,cshort height,calc_type alpha,calc_type beta)const{

	struct brd_val{
		board brd;
		pos_type pos;
		calc_type val;
	};
	typedef const brd_val& cbrd_val;

	#define trans_save(data) \
		if(mthd & mthd_trans){ \
			auto& trans_interval = trans_ptr->second; \
			if(data < beta_save){ \
				trans_interval.second = data; \
			} \
			if(data > alpha_save){ \
				trans_interval.first = data; \
			} \
		}

	#ifdef DEBUG_SEARCH
	auto fun = [&]()->calc_type{
	#endif

	if(mthd == mthd_rnd){
		return 0;
	}else{

		calc_type alpha_save,beta_save;
		trans_type::iterator trans_ptr;

		if(mthd & mthd_trans){
			trans_ptr = table_trans.find(*this);
			if(trans_ptr != table_trans.end()){
				auto& trans_interval = trans_ptr->second;
				if(trans_interval.first >= beta){
					return trans_interval.first;
					//return beta;
				}
				if(trans_interval.second <= alpha){
					return trans_interval.second;
					//return alpha;
				}
				if(trans_interval.first > alpha){
					alpha = trans_interval.first;
				}
				if(trans_interval.second < beta){
					beta = trans_interval.second;
				}
				assert(alpha <= beta);
			}else{
				trans_ptr = table_trans.insert(
					std::make_pair(*this,interval(_inf,inf))
				).first;
			}
			alpha_save = alpha;
			beta_save = beta;
		}

		if(height == 0){
			if(mthd & mthd_ptn)
				return this->score_ptn(color);
			else
				return this->score(color);
		}

		brd_val vec[32];
		brd_val* ptr = vec;
		calc_type result;
		calc_type* ptr_val = table_val[this->sum()];
		const method mthd_temp = method(mthd & ~mthd_pvs);
		brd_type brd_move = this->get_move(color);
		brd_type pos;

		ptr->brd = *this;
		asm volatile(
			"tzcnt %1, %0;"
			:"=&r"(pos)
			:"r"(brd_move)
			:
		);
		while(pos != size2){
			ptr->brd.flip(color,pos);
			if(mthd & mthd_kill){
				ptr->pos = pos;
				ptr->val = ptr_val[pos];
			}
			++ptr;
			ptr->brd = *this;
			asm volatile(
				"tzcnt %1, %0;"
				:"=&r"(pos)
				:"r"(brd_move & mask_after[pos])
				:
			);
		}

		if(ptr != vec){

			if(mthd & mthd_kill){
				make_heap(vec,ptr,
					[](cbrd_val b1,cbrd_val b2){
						return b1.val < b2.val;
					}
				);
			}

			for(brd_val* p = ptr;p != vec;){

				if(mthd & mthd_kill){
					pop_heap(vec,p,
						[](cbrd_val b1,cbrd_val b2){
							return b1.val < b2.val;
						}
					);
				}

				if(mthd & mthd_pvs){
					if(p != ptr){
						--p;
						result = - p->brd.template search<mthd_temp>(!color,height - 1,-alpha - 1,-alpha);
						if(result > alpha && result < beta)
							result = - p->brd.template search<mthd>(!color,height - 1,-beta,-alpha);
					}else{
						--p;
						result = - p->brd.template search<mthd>(!color,height - 1,-beta,-alpha);
					}
				}else{
					--p;
					result = - p->brd.template search<mthd>(!color,height - 1,-beta,-alpha);
				}
				if(mthd & mthd_kill){
					ptr_val[p->pos] = result;
				}
				if(result >= beta){
					trans_save(result);
					return beta;
				}
				if(result > alpha){
					alpha = result;
				}
			}

			trans_save(alpha);

			return alpha;

		}else{

			brd_move = this->get_move(!color);
			//ptr->brd = *this;
			asm volatile(
				"tzcnt %1, %0;"
				:"=&r"(pos)
				:"r"(brd_move)
				:
			);
			while(pos != size2){
				ptr->brd.flip(!color,pos);
				if(mthd & mthd_kill){
					ptr->pos = pos;
					ptr->val = ptr_val[pos];
				}
				++ptr;
				ptr->brd = *this;
				asm volatile(
					"tzcnt %1, %0;"
					:"=&r"(pos)
					:"r"(brd_move & mask_after[pos])
					:
				);
			}

			if(ptr != vec){

				if(mthd & mthd_kill){
					make_heap(vec,ptr,
						[](cbrd_val b1,cbrd_val b2){
							return b1.val > b2.val;
						}
					);
				}

				for(brd_val* p = ptr;p != vec;){

					if(mthd & mthd_kill){
						pop_heap(vec,p,
							[](cbrd_val b1,cbrd_val b2){
								return b1.val > b2.val;
							}
						);
					}

					if(mthd & mthd_pvs){
						if(p != ptr){
							--p;
							result = p->brd.template search<mthd_temp>(color,height - 1,beta - 1,beta);
							if(result > alpha && result < beta)
								result = p->brd.template search<mthd>(color,height - 1,alpha,beta);
						}else{
							--p;
							result = p->brd.template search<mthd>(color,height - 1,alpha,beta);
						}
					}else{
						--p;
						result = p->brd.template search<mthd>(color,height - 1,alpha,beta);
					}
					if(result <= alpha){
						trans_save(result);
						return alpha;
					}
					if(result < beta){
						beta = result;
					}
				}

				trans_save(beta)

				return beta;

			}else{

				calc_type num_diff = count(color) - count(!color);
				if(num_diff > 0){
					result =  num_diff + mark_max;
				}else if(num_diff < 0){
					result = num_diff - mark_max;
				}else{
					result = 0;
				}
				trans_save(result);
				return result;

			}
		}

	}

	#ifdef DEBUG_SEARCH
	};
	out << "<div color=" << color
		<< " height=" << height
		<< " alpha=" << alpha
		<< " beta=" << beta
		<< ">\n";
	this->print(out);
	calc_type result = fun();
	out << "result = " << result <<"\n"
		<< "</div>\n";
	return result;
	#endif
}

//Iterative_deepening(root)
//1:	firstguess <- 0
//2:	for depth = 1 to MAX_SEARCH_DEPTH do
//3:		firstguess <- MTDF(root, firstguess, depth)
//4:		if times_up() then
//5:		break
//6:	return firstguess

//if mthd & mthd_mtdf
//calc_type board::search_mtd(
//	cbool color,
//	cshort height,calc_type alpha,calc_type beta,
//	ccalc_type acc,cshort stage,calc_type gamma
//)const{
//	calc_type result = search_trans(color,height, gamma, gamma + 1, acc, stage);
//	if(result == gamma){
//		do{
//			--gamma;
//			result = search_trans(color,height, gamma, gamma + 1, acc, stage);
//		}while(result == gamma && result > alpha);
//	}else{
//		assert(result == gamma + 1);
//		do{
//			++gamma;
//			result = search_trans(color,height, gamma, gamma + 1, acc, stage);
//		}while(result == gamma + 1 && result < beta);
//	}
//	return result;
//}
